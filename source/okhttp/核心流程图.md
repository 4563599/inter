# OkHttp 核心流程图

本文档包含 OkHttp 各个关键流程的可视化图解。

---

## 1. 整体架构图

```
┌─────────────────────────────────────────────────────────┐
│                      用户代码                             │
│  OkHttpClient.newCall(request).execute()                │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│                    RealCall                              │
│  - 管理执行状态                                           │
│  - 构建拦截器链                                           │
│  - 同步/异步执行                                          │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────┐
│               RealInterceptorChain                       │
│  - 维护拦截器列表                                         │
│  - 递归调用 proceed()                                     │
└─────────────────────┬───────────────────────────────────┘
                      │
                      ▼
        ┌─────────────────────────┐
        │   Interceptor Chain     │
        └─────────────────────────┘
                      │
        ┌─────────────┴─────────────┐
        │                           │
        ▼                           ▼
┌───────────────┐           ┌──────────────┐
│ Application   │           │   Network    │
│ Interceptor   │           │ Interceptor  │
└───────┬───────┘           └──────┬───────┘
        │                          │
        └────────┬─────────────────┘
                 │
        ┌────────┴────────┐
        │                 │
        ▼                 ▼
    [Built-in Interceptors]
        │
        ├─ RetryAndFollowUpInterceptor
        ├─ BridgeInterceptor
        ├─ CacheInterceptor
        ├─ ConnectInterceptor
        └─ CallServerInterceptor
                 │
                 ▼
         ┌───────────────┐
         │   Response    │
         └───────────────┘
```

---

## 2. 同步请求流程

```
用户代码
   │
   │ call.execute()
   ▼
RealCall.execute()
   │
   ├─ 检查是否已执行
   │
   ├─ dispatcher.executed(this)  // 通知开始
   │
   ├─ getResponseWithInterceptorChain()
   │      │
   │      ├─ 构建拦截器列表
   │      │    ├─ Application Interceptors
   │      │    ├─ RetryAndFollowUpInterceptor
   │      │    ├─ BridgeInterceptor
   │      │    ├─ CacheInterceptor
   │      │    ├─ ConnectInterceptor
   │      │    ├─ Network Interceptors
   │      │    └─ CallServerInterceptor
   │      │
   │      └─ chain.proceed(request)
   │             │
   │             └─ 递归执行拦截器链
   │                    │
   │                    └─ 返回 Response
   │
   ├─ dispatcher.finished(this)  // 通知完成
   │
   └─ 返回 Response 给用户
```

---

## 3. 异步请求流程

```
用户代码
   │
   │ call.enqueue(callback)
   ▼
RealCall.enqueue(callback)
   │
   ├─ 检查是否已执行
   │
   ├─ 创建 AsyncCall(callback)
   │
   └─ dispatcher.enqueue(asyncCall)
         │
         ├─ 检查并发数
         │     │
         │     ├─ 未达到上限
         │     │     │
         │     │     ├─ runningAsyncCalls.add(call)
         │     │     └─ executorService.execute(call)
         │     │              │
         │     │              └─ 在线程池中执行
         │     │
         │     └─ 达到上限
         │           │
         │           └─ readyAsyncCalls.add(call)  // 加入等待队列
         │
         └─ AsyncCall.run()
               │
               ├─ getResponseWithInterceptorChain()
               │      │
               │      └─ 返回 Response
               │
               ├─ callback.onResponse(response)
               │      或
               │   callback.onFailure(exception)
               │
               └─ dispatcher.finished(asyncCall)
                     │
                     └─ promoteAndExecute()  // 从等待队列取下一个
```

---

## 4. 拦截器链执行流程

```
RealInterceptorChain.proceed(request)
   │
   ├─ index = 0
   │     │
   │     ├─ 创建 next chain (index = 1)
   │     │
   │     └─ interceptors[0].intercept(next)
   │           │
   │           ├─ 处理请求（修改 request）
   │           │
   │           ├─ chain.proceed(request)
   │           │     │
   │           │     ├─ index = 1
   │           │     │     │
   │           │     │     ├─ 创建 next chain (index = 2)
   │           │     │     │
   │           │     │     └─ interceptors[1].intercept(next)
   │           │     │           │
   │           │     │           ├─ 处理请求
   │           │     │           │
   │           │     │           ├─ chain.proceed(request)
   │           │     │           │     │
   │           │     │           │     └─ ... 继续递归 ...
   │           │     │           │           │
   │           │     │           │           └─ 最终到达 CallServerInterceptor
   │           │     │           │                    │
   │           │     │           │                    └─ 执行网络请求，返回 Response
   │           │     │           │
   │           │     │           └─ 处理响应（修改 response）
   │           │     │                    │
   │           │     │                    └─ 返回 Response
   │           │     │
   │           │     └─ 返回 Response
   │           │
   │           └─ 处理响应
   │                 │
   │                 └─ 返回 Response
   │
   └─ 返回 Response
```

**关键点：**
- 每次 `proceed()` 都创建新的 Chain 对象（index + 1）
- 形成递归调用
- 请求从外向内传递，响应从内向外返回
- 每个拦截器都可以修改请求和响应

---

## 5. 连接池工作流程

```
ConnectInterceptor.intercept()
   │
   ├─ 解析 URL (host, port)
   │
   ├─ connectionPool.get(host, port)
   │     │
   │     ├─ 遍历连接池
   │     │     │
   │     │     ├─ 找到匹配的连接？
   │     │     │     │
   │     │     │     ├─ 是：
   │     │     │     │    ├─ 检查是否已关闭
   │     │     │     │    ├─ connection.acquire()  // 引用计数 +1
   │     │     │     │    └─ 返回 connection
   │     │     │     │
   │     │     │     └─ 否：
   │     │     │          └─ 返回 null
   │     │     │
   │     │     └─ 返回结果
   │     │
   │     └─ 没有可用连接
   │           │
   │           ├─ 创建 new RealConnection(host, port)
   │           │
   │           ├─ connection.connect(timeout)
   │           │     │
   │           │     ├─ 创建 Socket
   │           │     ├─ socket.connect()  // TCP 三次握手
   │           │     └─ 获取 InputStream/OutputStream
   │           │
   │           └─ connection.acquire()
   │
   ├─ chain.proceed(request)  // 使用连接执行请求
   │     │
   │     └─ 返回 Response
   │
   ├─ connection.release()  // 引用计数 -1
   │
   └─ connectionPool.put(connection)  // 放回连接池
         │
         └─ connections.add(connection)


后台清理线程（cleanupRunnable）：
   │
   ├─ 定期执行 cleanup()
   │     │
   │     ├─ 遍历所有连接
   │     │     │
   │     │     ├─ 计算空闲时间
   │     │     │
   │     │     └─ 找出最长空闲的连接
   │     │
   │     ├─ 判断是否需要清理
   │     │     │
   │     │     ├─ 空闲时间 > keepAliveDuration？
   │     │     │     或
   │     │     │   空闲连接数 > maxIdleConnections？
   │     │     │     │
   │     │     │     ├─ 是：
   │     │     │     │    ├─ connections.remove(connection)
   │     │     │     │    └─ connection.close()
   │     │     │     │
   │     │     │     └─ 否：
   │     │     │          └─ 计算下次清理时间
   │     │     │
   │     │     └─ 继续等待
   │     │
   │     └─ 循环
   │
   └─ 结束
```

---

## 6. RetryAndFollowUpInterceptor 流程

```
RetryAndFollowUpInterceptor.intercept()
   │
   ├─ followUpCount = 0
   │
   └─ while (true)
         │
         ├─ try {
         │     │
         │     ├─ chain.proceed(request)
         │     │     │
         │     │     └─ 返回 Response
         │     │
         │     ├─ 检查是否需要重定向
         │     │     │
         │     │     └─ followUpRequest(response)
         │     │           │
         │     │           ├─ 检查状态码
         │     │           │     │
         │     │           │     ├─ 301/302/303/307/308？
         │     │           │     │     │
         │     │           │     │     ├─ 是：
         │     │           │     │     │    ├─ 获取 Location 头
         │     │           │     │     │    ├─ 构建新请求
         │     │           │     │     │    └─ 返回新请求
         │     │           │     │     │
         │     │           │     │     └─ 否：
         │     │           │     │          └─ 返回 null
         │     │           │     │
         │     │           │     └─ 返回结果
         │     │           │
         │     │           └─ 不需要重定向
         │     │                 │
         │     │                 └─ 返回 Response 给用户
         │     │
         │     └─ 需要重定向
         │           │
         │           ├─ followUpCount++
         │           │
         │           ├─ followUpCount > MAX_FOLLOW_UPS？
         │           │     │
         │           │     ├─ 是：抛出异常 "重定向次数过多"
         │           │     │
         │           │     └─ 否：
         │           │          ├─ request = followUp
         │           │          └─ continue  // 重新执行循环
         │           │
         │           └─ 继续循环
         │
         └─ } catch (IOException e) {
               │
               ├─ 检查是否可以重试
               │     │
               │     └─ isRecoverable(e)
               │           │
               │           ├─ SocketTimeoutException？ → 可以重试
               │           ├─ Connection reset？ → 可以重试
               │           └─ 其他 → 可以重试
               │
               ├─ 可以重试
               │     │
               │     └─ continue  // 重新执行循环
               │
               └─ 不能重试
                     │
                     └─ throw e  // 抛出异常
```

---

## 7. HTTP 请求/响应格式

### 请求格式

```
┌────────────────────────────────────┐
│  GET /api/users HTTP/1.1           │ ← 请求行
├────────────────────────────────────┤
│  Host: example.com                 │ ← 请求头
│  User-Agent: MyOkHttp/1.0          │
│  Content-Type: application/json    │
│  Content-Length: 27                │
│  Connection: Keep-Alive            │
│  Accept-Encoding: gzip             │
├────────────────────────────────────┤
│                                    │ ← 空行（CRLF）
├────────────────────────────────────┤
│  {"name":"张三","age":25}          │ ← 请求体（可选）
└────────────────────────────────────┘
```

### 响应格式

```
┌────────────────────────────────────┐
│  HTTP/1.1 200 OK                   │ ← 状态行
├────────────────────────────────────┤
│  Content-Type: application/json    │ ← 响应头
│  Content-Length: 123               │
│  Connection: Keep-Alive            │
│  Date: Wed, 05 Nov 2025 07:00:00   │
├────────────────────────────────────┤
│                                    │ ← 空行（CRLF）
├────────────────────────────────────┤
│  {"id":1,"name":"张三","age":25}   │ ← 响应体
└────────────────────────────────────┘
```

---

## 8. 状态机：Call 的生命周期

```
           [创建]
             │
             │ newCall(request)
             ▼
         ┌─────────┐
         │  Idle   │  ← 初始状态
         └─────────┘
             │
             │ execute() 或 enqueue()
             ▼
         ┌─────────┐
         │Executing│  ← 执行中
         └─────────┘
             │
      ┌──────┴──────┐
      │             │
      │ 成功        │ 失败/取消
      ▼             ▼
  ┌─────────┐   ┌─────────┐
  │Completed│   │ Failed  │  ← 结束状态
  └─────────┘   └─────────┘

注意：每个 Call 只能执行一次！
如果需要重复执行，使用 call.clone()
```

---

## 9. 线程模型

```
┌─────────────────────────────────────────────────────────┐
│                      主线程                              │
│                                                          │
│  client.newCall(request).execute()    ← 同步：阻塞主线程  │
│                                                          │
│  client.newCall(request).enqueue()    ← 异步：不阻塞     │
└─────────────────────┬───────────────────────────────────┘
                      │
          ┌───────────┴───────────┐
          │                       │
          ▼                       ▼
   [同步请求]               [异步请求]
   在主线程执行         提交到 Dispatcher
          │                       │
          │                       ▼
          │              ┌─────────────────┐
          │              │  Dispatcher     │
          │              │  ┌───────────┐  │
          │              │  │Thread Pool│  │
          │              │  └───────────┘  │
          │              └────────┬────────┘
          │                       │
          │              ┌────────┴────────┐
          │              │                 │
          │              ▼                 ▼
          │         [Worker 1]        [Worker 2]
          │              │                 │
          │              ├─ AsyncCall 1   │
          │              ├─ AsyncCall 2   │
          │              └─ ...            └─ ...
          │                       │
          └───────────────────────┤
                                  │
                                  ▼
                          [执行拦截器链]
                                  │
                                  ▼
                          [网络 I/O]
                                  │
                      ┌───────────┴───────────┐
                      │                       │
                      ▼                       ▼
              [同步：返回结果]      [异步：回调]
              在主线程返回          在工作线程回调
```

---

## 10. 性能优化点

```
1. 连接复用
   ┌──────────────────────────────────────┐
   │  请求1 → [建立连接] → 响应1          │  ← 耗时
   │  请求2 → [复用连接] → 响应2          │  ← 快速！
   │  请求3 → [复用连接] → 响应3          │  ← 快速！
   └──────────────────────────────────────┘

2. 并发控制
   ┌──────────────────────────────────────┐
   │  maxRequests = 64                    │
   │  ┌────────────────────┐              │
   │  │ Running (64)       │              │
   │  │ ├─ Request 1       │              │
   │  │ ├─ Request 2       │              │
   │  │ └─ ...             │              │
   │  └────────────────────┘              │
   │  ┌────────────────────┐              │
   │  │ Ready (queue)      │ ← 等待执行   │
   │  │ ├─ Request 65      │              │
   │  │ ├─ Request 66      │              │
   │  │ └─ ...             │              │
   │  └────────────────────┘              │
   └──────────────────────────────────────┘

3. 拦截器复用
   同一个拦截器实例被所有请求共享
   节省内存，提高性能

4. 不可变对象
   Request 和 Response 不可变
   线程安全，无需加锁
```

---

**通过这些流程图，你应该对 OkHttp 的工作原理有了更直观的理解！** 🎨

