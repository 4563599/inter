# Kotlin 反射 - 函数引用

## 📖 函数引用概述

函数引用允许我们将函数作为值来传递和使用，这是函数式编程的重要特性。

---

## 1. 基本函数引用

### 示例代码：HelloKotlin3.kt

```kotlin
// 定义两个重载的函数
fun multiplyBy3(x: Int): Int {
    return 3 * x
}

fun multiplyBy3(s: String): Int {
    return 10
}

fun main(args: Array<String>) {
    val values = listOf(1, 2, 3, 4)
    println(values.map(::multiplyBy3))  // 输出：[3, 6, 9, 12]

    println("-------")

    val values2 = listOf("a", "b", "c", "d")
    println(values2.map(::multiplyBy3)) // 输出：[10, 10, 10, 10]
}

// 函数引用赋值给变量
val myReference: (Int) -> Int = ::multiplyBy3
val myReference2: (String) -> Int = ::multiplyBy3
val myReference3: String.(Int) -> Char = String::get
```

**知识点：**
- 使用 `::函数名` 来引用函数
- Kotlin 支持函数重载，会根据上下文自动选择正确的重载版本
- 函数引用可以赋值给变量，类型为函数类型 `(参数) -> 返回值`
- `String::get` 是成员函数引用，类型为 `String.(Int) -> Char`

**打印提示：**
- `map(::multiplyBy3)` 会根据集合元素类型自动选择对应的重载函数
- Int 列表调用 `multiplyBy3(Int)` 版本
- String 列表调用 `multiplyBy3(String)` 版本

---

## 2. 函数组合

### 示例代码：HelloKotlin4.kt

```kotlin
// 定义函数组合：将两个函数组合成一个新函数
fun <A, B, C> myCompose(f: (B) -> C, g: (A) -> B): (A) -> C {
    return { x -> f(g(x)) }  // 先执行 g，再执行 f
}

fun isEven(x: Int) = 0 == x % 2  // 判断是否为偶数

fun length(s: String) = s.length  // 获取字符串长度

fun main(args: Array<String>) {
    // 组合两个函数：先获取长度，再判断长度是否为偶数
    val evenLength = myCompose(::isEven, ::length)
    val strings = listOf("a", "ab", "abc", "abcd", "abcde")

    println(strings.filter(evenLength))  // 输出：[ab, abcd]（长度为偶数的字符串）
}
```

**知识点：**
- 函数可以作为参数传递和返回
- 函数组合是函数式编程的重要概念
- `myCompose(f, g)` 创建新函数，等价于 `f(g(x))`
- 泛型函数可以组合任意类型的函数

**执行流程：**
1. `evenLength` 是组合后的函数
2. 对于 "ab"：先执行 `length("ab")` 得到 2，再执行 `isEven(2)` 得到 true
3. 对于 "abc"：先执行 `length("abc")` 得到 3，再执行 `isEven(3)` 得到 false

---

## 3. 构造方法引用

### 示例代码：HelloKotlin9.kt

```kotlin
class B(val x: Int)

fun myMethod(factory: (x: Int) -> B) {
    val b: B = factory(3)  // 使用工厂函数创建对象
    println(b.x)           // 输出：3
}

fun main(args: Array<String>) {
    myMethod(::B)  // 传入构造方法引用
}
```

**知识点：**
- 使用 `::类名` 引用构造方法
- 构造方法引用可以作为工厂函数使用
- 要求：
  1. 参数类型和个数必须匹配
  2. 返回类型必须是该类的类型

**应用场景：**
- 工厂模式
- 依赖注入
- 延迟初始化

---

## 4. 特定对象的方法引用

### 示例代码：HelloKotlin10.kt

```kotlin
fun main(args: Array<String>) {
    val str = "abc"
    val getReference = str::get  // 引用特定对象的方法
    println(getReference(1))     // 输出：b

    println("-------")

    val myProp = "test"::length  // 引用特定对象的属性
    println(myProp.get())        // 输出：4

    println("-------")

    val myProp2 = String::length // 引用类的属性
    println(myProp2.get("test")) // 输出：4（需要传入对象）
}
```

**知识点：**
- `对象::方法` 引用特定对象的方法，调用时不需要传入接收者
- `对象::属性` 引用特定对象的属性
- `类::属性` 引用类的属性，调用时需要传入对象实例

**区别：**
- `str::get` 已经绑定了 "abc" 对象，调用时只需传入索引
- `String::get` 没有绑定对象，调用时需要传入字符串和索引

---

## 💡 总结

1. **函数引用语法**：`::函数名` 或 `类名::方法名`
2. **支持重载**：根据上下文自动选择正确的重载版本
3. **函数组合**：可以将多个函数组合成新函数
4. **构造方法引用**：`::类名` 可以作为工厂函数
5. **绑定引用**：`对象::方法` 已绑定接收者，`类::方法` 未绑定
