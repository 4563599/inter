# 责任链模式入门指南

> 目标：一步步学会责任链模式，并结合 `chain/ChainExample.java` 的示例理解如何在 Android/Java 中编写。

## 1. 责任链模式要解决什么问题？
- 需要多个处理者依次尝试处理同一个请求，比如日志过滤、权限校验、表单验证。
- 让处理节点之间“松耦合”：每个节点只处理自己关心的部分，处理不了就交给下一个。
- 方便扩展：新增/移除节点只需改装链条，不必改动已有逻辑。

## 2. 开始前的准备
1. 想清楚“请求”长什么样（可以是 Java Bean、Map、POJO）。
2. 列出每个处理者的职责，比如“检查登录状态”“检查网络”“执行真正业务”。
3. 确认节点之间遵守同一个接口：`handle(request)`，无法处理时把请求传给下一个。

## 3. 实现步骤（以 `chain/ChainExample.java` 为例）
> 按步骤抄一遍就能熟悉套路。

### 步骤 3.1：定义请求数据
```java
class UserRequest {
    private final String userName;
    private final String password;
    private final boolean hasNetwork;
    // 构造函数 + getter 见示例文件
}
```
- 一份请求只出现一份信息，避免在节点间重复传参。

### 步骤 3.2：创建 Handler 抽象基类
```java
abstract class Handler {
    private Handler next;

    Handler setNext(Handler next) {
        this.next = next;
        return next;
    }

    void handle(UserRequest request) {
        if (!process(request) && next != null) {
            next.handle(request);
        }
    }

    protected abstract boolean process(UserRequest request);
}
```
- `setNext` 用流式写法便于链式拼接。
- `process` 返回 `true` 表示“已经处理完，不再往后传”。

### 步骤 3.3：实现具体处理者
```java
class AuthHandler extends Handler { /* 检查用户名/密码是否为空 */ }
class NetworkHandler extends Handler { /* 检查网络是否可用 */ }
class BusinessHandler extends Handler { /* 真正执行业务逻辑 */ }
```
- 每个类里只写自己的判断，不能处理时返回 `false`。

### 步骤 3.4：组装链条并发送请求
```java
Handler auth = new AuthHandler();
Handler network = new NetworkHandler();
Handler business = new BusinessHandler();

auth.setNext(network).setNext(business);

auth.handle(new UserRequest("Codex", "123456", true));
```
- 记住只需要让第一个节点 `handle`，其他节点会自动串联。

### 步骤 3.5：运行观察日志
- `AuthHandler`、`NetworkHandler`、`BusinessHandler` 都会打印各自的提示，便于理解流程。
- 修改请求字段就能看到链路在不同场景下的行为。

## 4. Android 中的常见应用场景

### 4.1 View 事件分发机制（最经典）⭐⭐⭐⭐⭐
**这是 Android 中责任链模式最经典的应用！**

```java
// 触摸事件的责任链流程
Activity
  ↓ dispatchTouchEvent()
  ↓ 传递给 Window
ViewGroup (根布局)
  ↓ dispatchTouchEvent()
  ↓ onInterceptTouchEvent() - 是否拦截？
  ↓ 不拦截，传给子 View
ViewGroup (子布局)
  ↓ dispatchTouchEvent()
  ↓ onInterceptTouchEvent() - 是否拦截？
  ↓ 不拦截，传给子 View
View (按钮/文本等)
  ↓ dispatchTouchEvent()
  ↓ onTouchEvent() - 处理事件
```

**示例代码**：
```java
public class MyViewGroup extends ViewGroup {
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // 决定是否拦截事件（责任链的关键）
        if (shouldIntercept()) {
            return true;  // 拦截，自己处理，不再传递
        }
        return false;  // 不拦截，传给子 View
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 处理事件
        if (handleEvent(event)) {
            return true;  // 消费事件，不再往上传递
        }
        return false;  // 不消费，继续往上传递
    }
}
```

**责任链特点**：
- 每个 ViewGroup 都是一个处理节点
- `onInterceptTouchEvent` 决定是否拦截（是否处理）
- 不拦截就传给子 View，拦截就自己处理
- 如果子 View 不处理，事件会回传给父 View

**实际应用**：
- 解决滑动冲突（ScrollView 嵌套 RecyclerView）
- 自定义手势处理（下拉刷新、侧滑删除）
- 点击事件的优先级控制

---

### 4.2 OkHttp 拦截器链 ⭐⭐⭐⭐⭐
**网络请求中的责任链模式**

```java
// OkHttp 的拦截器就是责任链
OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new LoggingInterceptor())      // 1. 日志拦截器
    .addInterceptor(new HeaderInterceptor())       // 2. 添加请求头
    .addInterceptor(new CacheInterceptor())        // 3. 缓存拦截器
    .addInterceptor(new RetryInterceptor())        // 4. 重试拦截器
    .build();

// 每个拦截器都可以决定是否继续传递请求
class LoggingInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();
        
        // 请求前的处理
        Log.d("OkHttp", "请求: " + request.url());
        long startTime = System.currentTimeMillis();
        
        // 传递给下一个拦截器（责任链的关键）
        Response response = chain.proceed(request);
        
        // 响应后的处理
        long duration = System.currentTimeMillis() - startTime;
        Log.d("OkHttp", "响应: " + response.code() + " 耗时: " + duration + "ms");
        
        return response;
    }
}
```

**责任链流程**：
```
请求 → LoggingInterceptor → HeaderInterceptor → CacheInterceptor 
     → RetryInterceptor → 网络请求 → 响应
     ← LoggingInterceptor ← HeaderInterceptor ← CacheInterceptor 
     ← RetryInterceptor ← 网络响应 ← 响应
```

**实际应用**：
- 统一添加请求头（Token、User-Agent）
- 日志记录（请求/响应内容）
- 缓存处理（读取/保存缓存）
- 重试机制（网络失败自动重试）
- 数据加密/解密

---

### 4.3 Jetpack WorkManager 工作链 ⭐⭐⭐⭐
**后台任务的责任链**

```java
// 创建工作链：下载 → 处理 → 上传
WorkManager.getInstance(context)
    .beginWith(downloadWork)           // 第一步：下载文件
    .then(processWork)                 // 第二步：处理文件
    .then(uploadWork)                  // 第三步：上传文件
    .enqueue();

// 每个 Worker 处理完后，自动传递给下一个
class DownloadWorker extends Worker {
    @Override
    public Result doWork() {
        // 下载文件
        boolean success = downloadFile();
        
        if (success) {
            return Result.success();  // 成功，传递给下一个 Worker
        } else {
            return Result.failure();  // 失败，终止链条
        }
    }
}
```

**责任链特点**：
- 每个 Worker 是一个处理节点
- 前一个 Worker 成功后，才会执行下一个
- 任何一个 Worker 失败，整个链条终止

---

### 4.4 广播接收器的优先级处理 ⭐⭐⭐
**按优先级处理广播**

```xml
<!-- 高优先级接收器 -->
<receiver android:name=".HighPriorityReceiver">
    <intent-filter android:priority="1000">
        <action android:name="com.example.MY_BROADCAST"/>
    </intent-filter>
</receiver>

<!-- 低优先级接收器 -->
<receiver android:name=".LowPriorityReceiver">
    <intent-filter android:priority="1">
        <action android:name="com.example.MY_BROADCAST"/>
    </intent-filter>
</receiver>
```

```java
// 高优先级接收器可以终止广播传递
public class HighPriorityReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理广播
        Log.d("Receiver", "高优先级接收器处理");
        
        if (shouldAbort()) {
            abortBroadcast();  // 终止传递，后续接收器收不到
        }
        // 不调用 abortBroadcast()，广播继续传递给低优先级接收器
    }
}
```

---

### 4.5 Retrofit 的 CallAdapter 和 Converter 链 ⭐⭐⭐
**数据转换的责任链**

```java
Retrofit retrofit = new Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create())      // JSON 转换
    .addConverterFactory(ScalarsConverterFactory.create())   // 字符串转换
    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // RxJava 适配
    .build();

// 每个 Converter 尝试处理，处理不了就传给下一个
// 类似责任链模式
```

---

### 4.6 Android 权限请求链 ⭐⭐⭐
**链式处理多个权限请求**

```java
class PermissionChain {
    private List<String> permissions = Arrays.asList(
        Manifest.permission.CAMERA,
        Manifest.permission.WRITE_EXTERNAL_STORAGE,
        Manifest.permission.RECORD_AUDIO
    );
    private int currentIndex = 0;
    
    public void requestNext(Activity activity) {
        if (currentIndex < permissions.size()) {
            String permission = permissions.get(currentIndex);
            
            if (ContextCompat.checkSelfPermission(activity, permission) 
                    != PackageManager.PERMISSION_GRANTED) {
                // 请求权限
                ActivityCompat.requestPermissions(activity, 
                    new String[]{permission}, currentIndex);
            } else {
                // 已有权限，请求下一个
                currentIndex++;
                requestNext(activity);
            }
        } else {
            // 所有权限请求完成
            onAllPermissionsGranted();
        }
    }
    
    public void onPermissionResult(boolean granted) {
        if (granted) {
            currentIndex++;
            requestNext(activity);
        } else {
            onPermissionDenied();
        }
    }
}
```

---

### 4.7 自定义表单验证链 ⭐⭐⭐⭐
**链式验证表单字段**

```java
// 验证器基类
abstract class Validator {
    private Validator next;
    
    public Validator setNext(Validator next) {
        this.next = next;
        return next;
    }
    
    public boolean validate(String input) {
        if (!check(input)) {
            return false;  // 验证失败
        }
        if (next != null) {
            return next.validate(input);  // 传给下一个验证器
        }
        return true;  // 所有验证通过
    }
    
    protected abstract boolean check(String input);
}

// 非空验证器
class NotEmptyValidator extends Validator {
    @Override
    protected boolean check(String input) {
        if (input == null || input.isEmpty()) {
            Toast.makeText(context, "不能为空", Toast.LENGTH_SHORT).show();
            return false;
        }
        return true;
    }
}

// 最小长度验证器
class MinLengthValidator extends Validator {
    private int minLength;
    
    public MinLengthValidator(int minLength) {
        this.minLength = minLength;
    }
    
    @Override
    protected boolean check(String input) {
        if (input.length() < minLength) {
            Toast.makeText(context, "长度不能少于" + minLength, Toast.LENGTH_SHORT).show();
            return false;
        }
        return true;
    }
}

// 包含数字验证器
class HasNumberValidator extends Validator {
    @Override
    protected boolean check(String input) {
        if (!input.matches(".*\\d.*")) {
            Toast.makeText(context, "必须包含数字", Toast.LENGTH_SHORT).show();
            return false;
        }
        return true;
    }
}

// 使用验证链
Validator notEmpty = new NotEmptyValidator();
Validator minLength = new MinLengthValidator(6);
Validator hasNumber = new HasNumberValidator();

notEmpty.setNext(minLength).setNext(hasNumber);

// 验证密码
String password = editText.getText().toString();
if (notEmpty.validate(password)) {
    // 密码验证通过，提交表单
    submitForm();
}
```

---

### 4.8 系统服务的责任链 ⭐⭐
**系统服务的层级调用**

```java
// Context 的 getSystemService 就是一个责任链
Context context = getApplicationContext();

// 每个 Context 实现类都会尝试处理
// ContextImpl → ContextWrapper → Activity/Service
Object service = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
```

---

## 5. 责任链模式的优缺点

### 优点 ✅
1. **降低耦合**：请求发送者和接收者解耦
2. **灵活性高**：可以动态添加/删除/调整节点顺序
3. **职责单一**：每个节点只处理自己关心的部分
4. **易于扩展**：新增节点不影响现有代码

### 缺点 ❌
1. **性能问题**：请求可能要经过很多节点才能被处理
2. **调试困难**：链条太长时，难以定位问题
3. **可能无法处理**：如果所有节点都不处理，请求会被丢弃

---

## 6. 责任链模式 vs 其他模式

| 模式 | 区别 | 使用场景 |
|------|------|----------|
| **责任链** | 多个对象依次尝试处理请求 | 事件分发、拦截器、表单验证 |
| **装饰器** | 多个对象依次增强功能 | 动态添加功能（如 Java IO） |
| **策略** | 多个算法中选择一个 | 支付方式、排序算法 |
| **观察者** | 一对多通知 | 事件监听、数据绑定 |

## 5. 学完后可以做什么？
- 新增一个 Handler（如“冷却时间检查”）只需继承 `Handler` 并插入链条。
- 把该套路迁移到实际业务，比如：多重缓存读取（内存→磁盘→网络）、日志过滤、管道式拦截。
- 在 Android 工程里，把 Handler 写成 Java/Kotlin 类，通过依赖注入灵活拼装。

想继续练习？复制 `chain/ChainExample.java`，尝试添加新的节点（如“风控校验”），然后在 `main` 中调整链路顺序感受不同效果。
