# 原型模式入门指南

> 目标：一步步学会原型模式，并结合 `prototype/PrototypeExample.java` 的示例理解如何在 Android/Java 中编写。

## 1. 原型模式要解决什么问题？

- **创建对象成本高**：当创建一个对象需要复杂的初始化过程（如读取数据库、网络请求、复杂计算）时，每次都重新创建太浪费资源。
- **需要大量相似对象**：比如游戏中的怪物、文档编辑器中的图形元素，它们有相同的基础属性，只需要微调部分字段。
- **避免构造函数的复杂性**：通过复制现有对象来创建新对象，而不是通过 `new` 和复杂的构造函数。

**核心思想**：通过"克隆"（复制）一个已有对象来创建新对象，而不是从头创建。

## 2. 开始前的准备

1. **确定哪些对象需要被克隆**：通常是创建成本高、或需要大量相似实例的对象。
2. **决定克隆的深度**：
   - **浅克隆**：只复制对象本身，对象内的引用类型字段仍指向原来的对象。
   - **深克隆**：完全复制对象及其内部的所有引用对象，创建一个完全独立的副本。
3. **实现 Cloneable 接口**：Java 中需要实现 `Cloneable` 接口并重写 `clone()` 方法。

## 3. 实现步骤（以 `prototype/PrototypeExample.java` 为例）

> 按步骤抄一遍就能熟悉套路。

### 步骤 3.1：定义原型接口（可选）

```java
// 定义一个原型接口，规定所有原型对象都要有 clone 方法
interface Prototype {
    Prototype clone();
}
```
- 这一步是可选的，也可以直接使用 Java 的 `Cloneable` 接口。
- 自定义接口的好处是返回类型更明确，不需要强制类型转换。

### 步骤 3.2：创建具体的原型类（浅克隆示例）

```java
// 浅克隆：只复制对象本身，引用类型字段仍指向原对象
class Monster implements Cloneable {
    private String name;      // 基本类型字段
    private int health;       // 基本类型字段
    private Weapon weapon;    // 引用类型字段（浅克隆时不会复制）
    
    // 构造函数
    public Monster(String name, int health, Weapon weapon) {
        this.name = name;
        this.health = health;
        this.weapon = weapon;
    }
    
    // 重写 clone 方法实现浅克隆
    @Override
    public Monster clone() {
        try {
            // 调用 Object 的 clone() 方法
            return (Monster) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("克隆失败", e);
        }
    }
    
    // getter 和 setter 方法...
}
```

**关键点**：
- 实现 `Cloneable` 接口（标记接口，没有方法）
- 重写 `clone()` 方法，调用 `super.clone()`
- 浅克隆：`weapon` 字段在克隆后仍指向同一个对象

### 步骤 3.3：创建深克隆示例

```java
// 深克隆：完全复制对象及其内部的所有引用对象
class DeepMonster implements Cloneable {
    private String name;
    private int health;
    private Weapon weapon;    // 这次要深度复制
    
    public DeepMonster(String name, int health, Weapon weapon) {
        this.name = name;
        this.health = health;
        this.weapon = weapon;
    }
    
    // 重写 clone 方法实现深克隆
    @Override
    public DeepMonster clone() {
        try {
            DeepMonster cloned = (DeepMonster) super.clone();
            // 手动克隆引用类型字段，实现深克隆
            cloned.weapon = this.weapon.clone();
            return cloned;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("克隆失败", e);
        }
    }
}

// Weapon 类也要实现 Cloneable
class Weapon implements Cloneable {
    private String name;
    private int damage;
    
    @Override
    public Weapon clone() {
        try {
            return (Weapon) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("克隆失败", e);
        }
    }
}
```

**关键点**：
- 深克隆需要手动克隆所有引用类型字段
- 引用类型字段（如 `Weapon`）也要实现 `Cloneable`

### 步骤 3.4：使用原型模式创建对象

```java
public class PrototypeExample {
    public static void main(String[] args) {
        // 1. 创建原型对象（模板）
        Weapon sword = new Weapon("铁剑", 50);
        Monster originalMonster = new Monster("哥布林", 100, sword);
        
        // 2. 通过克隆创建新对象
        Monster clonedMonster1 = originalMonster.clone();
        Monster clonedMonster2 = originalMonster.clone();
        
        // 3. 修改克隆对象的属性
        clonedMonster1.setName("哥布林战士");
        clonedMonster1.setHealth(150);
        
        clonedMonster2.setName("哥布林法师");
        clonedMonster2.setHealth(80);
        
        // 4. 观察浅克隆的效果
        // 修改原型的武器，所有浅克隆对象的武器都会改变
        sword.setDamage(100);
        
        System.out.println("原型: " + originalMonster);
        System.out.println("克隆1: " + clonedMonster1);
        System.out.println("克隆2: " + clonedMonster2);
    }
}
```

### 步骤 3.5：运行观察结果

- 浅克隆：修改原型的 `weapon`，所有克隆对象的 `weapon` 都会改变（因为它们指向同一个对象）
- 深克隆：修改原型的 `weapon`，克隆对象的 `weapon` 不受影响（因为是完全独立的副本）

## 4. 浅克隆 vs 深克隆对比表

| 特性 | 浅克隆 | 深克隆 |
|------|--------|--------|
| **基本类型字段** | 复制值 | 复制值 |
| **引用类型字段** | 复制引用（指向同一对象） | 复制对象（创建新对象） |
| **实现难度** | 简单，直接调用 `super.clone()` | 复杂，需要递归克隆所有引用字段 |
| **性能** | 快 | 慢（需要复制更多对象） |
| **独立性** | 部分独立（引用字段共享） | 完全独立 |
| **使用场景** | 引用字段不会被修改，或希望共享 | 需要完全独立的副本 |

## 5. Android 中的常见应用场景

### 5.1 Intent 的克隆
```java
// Android 的 Intent 实现了 Cloneable
Intent originalIntent = new Intent(this, MainActivity.class);
originalIntent.putExtra("key", "value");

// 克隆 Intent
Intent clonedIntent = (Intent) originalIntent.clone();
clonedIntent.putExtra("key", "newValue");  // 修改不影响原 Intent
```

### 5.2 Bitmap 的复制
```java
// 复制 Bitmap 对象
Bitmap originalBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image);
Bitmap clonedBitmap = originalBitmap.copy(originalBitmap.getConfig(), true);

// 修改克隆的 Bitmap 不影响原 Bitmap
Canvas canvas = new Canvas(clonedBitmap);
canvas.drawColor(Color.RED);
```

### 5.3 Bundle 的克隆
```java
// Bundle 也实现了 Cloneable
Bundle originalBundle = new Bundle();
originalBundle.putString("name", "张三");

Bundle clonedBundle = (Bundle) originalBundle.clone();
clonedBundle.putString("name", "李四");  // 不影响原 Bundle
```

### 5.4 游戏开发中的敌人/道具克隆
```java
// 创建一个敌人模板
Enemy enemyTemplate = new Enemy("哥布林", 100, 10);

// 快速创建大量相似的敌人
List<Enemy> enemies = new ArrayList<>();
for (int i = 0; i < 100; i++) {
    Enemy enemy = enemyTemplate.clone();
    enemy.setPosition(randomX(), randomY());  // 只修改位置
    enemies.add(enemy);
}
```

### 5.5 配置对象的复制
```java
// 复制应用配置，用于不同环境
AppConfig devConfig = new AppConfig("dev", "http://dev.api.com");
AppConfig prodConfig = devConfig.clone();
prodConfig.setEnvironment("prod");
prodConfig.setApiUrl("http://api.com");
```

### 5.6 RecyclerView 中的数据克隆
```java
// 在 RecyclerView 中，克隆数据用于编辑，避免直接修改原数据
class EditActivity extends AppCompatActivity {
    private User originalUser;
    private User editingUser;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        originalUser = getIntent().getParcelableExtra("user");
        // 克隆一份用于编辑，取消时不影响原数据
        editingUser = originalUser.clone();
    }
    
    private void onSaveClick() {
        // 保存时才更新原数据
        originalUser.copyFrom(editingUser);
    }
}
```

## 6. 责任链模式在 Android 中的常见应用场景

### 6.1 View 事件分发机制（最经典）
```java
// Android 的触摸事件分发就是一个完整的责任链
ViewGroup (Activity/Fragment)
    ↓ dispatchTouchEvent
    ↓ onInterceptTouchEvent (是否拦截)
ViewGroup (布局容器)
    ↓ dispatchTouchEvent
    ↓ onInterceptTouchEvent
View (按钮/文本等)
    ↓ dispatchTouchEvent
    ↓ onTouchEvent (处理事件)
```

**示例**：
```java
public class MyViewGroup extends ViewGroup {
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // 决定是否拦截事件，不拦截就传给子 View
        if (shouldIntercept()) {
            return true;  // 拦截，自己处理
        }
        return false;  // 不拦截，传给子 View
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        // 处理事件
        return true;  // 消费事件，不再往上传递
    }
}
```

### 6.2 OkHttp 拦截器链
```java
// OkHttp 的拦截器就是责任链模式
OkHttpClient client = new OkHttpClient.Builder()
    .addInterceptor(new LoggingInterceptor())      // 日志拦截器
    .addInterceptor(new HeaderInterceptor())       // 添加请求头
    .addInterceptor(new CacheInterceptor())        // 缓存拦截器
    .addInterceptor(new RetryInterceptor())        // 重试拦截器
    .build();

// 每个拦截器都可以决定是否继续传递请求
class LoggingInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();
        Log.d("OkHttp", "请求: " + request.url());
        
        // 传递给下一个拦截器
        Response response = chain.proceed(request);
        
        Log.d("OkHttp", "响应: " + response.code());
        return response;
    }
}
```

### 6.3 Jetpack WorkManager 的工作链
```java
// WorkManager 可以创建工作链
WorkManager.getInstance(context)
    .beginWith(downloadWork)           // 第一步：下载
    .then(processWork)                 // 第二步：处理
    .then(uploadWork)                  // 第三步：上传
    .enqueue();

// 每个 Worker 处理完后，自动传递给下一个
```

### 6.4 广播接收器的优先级处理
```java
// 多个 BroadcastReceiver 按优先级处理广播
<receiver android:name=".HighPriorityReceiver">
    <intent-filter android:priority="1000">
        <action android:name="com.example.MY_BROADCAST"/>
    </intent-filter>
</receiver>

<receiver android:name=".LowPriorityReceiver">
    <intent-filter android:priority="1">
        <action android:name="com.example.MY_BROADCAST"/>
    </intent-filter>
</receiver>

// 高优先级的 Receiver 可以决定是否终止传递
public class HighPriorityReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理广播
        if (shouldAbort()) {
            abortBroadcast();  // 终止传递，后续 Receiver 收不到
        }
    }
}
```

### 6.5 Retrofit 的 CallAdapter 和 Converter 链
```java
// Retrofit 内部使用责任链处理请求和响应
Retrofit retrofit = new Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create())      // JSON 转换
    .addConverterFactory(ScalarsConverterFactory.create())   // 字符串转换
    .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) // RxJava 适配
    .build();

// 每个 Converter 尝试处理，处理不了就传给下一个
```

### 6.6 Android 权限请求链
```java
// 链式处理多个权限请求
class PermissionChain {
    private List<String> permissions;
    private int currentIndex = 0;
    
    public void requestNext(Activity activity) {
        if (currentIndex < permissions.size()) {
            String permission = permissions.get(currentIndex);
            if (ContextCompat.checkSelfPermission(activity, permission) 
                    != PackageManager.PERMISSION_GRANTED) {
                // 请求权限
                ActivityCompat.requestPermissions(activity, 
                    new String[]{permission}, currentIndex);
            } else {
                // 已有权限，请求下一个
                currentIndex++;
                requestNext(activity);
            }
        } else {
            // 所有权限请求完成
            onAllPermissionsGranted();
        }
    }
}
```

### 6.7 自定义表单验证链
```java
// 表单验证的责任链
abstract class Validator {
    private Validator next;
    
    public Validator setNext(Validator next) {
        this.next = next;
        return next;
    }
    
    public boolean validate(String input) {
        if (!check(input)) {
            return false;  // 验证失败
        }
        if (next != null) {
            return next.validate(input);  // 传给下一个验证器
        }
        return true;  // 所有验证通过
    }
    
    protected abstract boolean check(String input);
}

// 使用
Validator notEmpty = new NotEmptyValidator();
Validator minLength = new MinLengthValidator(6);
Validator hasNumber = new HasNumberValidator();

notEmpty.setNext(minLength).setNext(hasNumber);

if (notEmpty.validate(password)) {
    // 密码验证通过
}
```

## 7. 学完后可以做什么？

- **原型模式**：
  - 在游戏中快速创建大量相似的敌人、道具、子弹等对象
  - 复制配置对象用于不同环境（开发/测试/生产）
  - 在编辑功能中克隆数据，避免直接修改原数据
  - 实现撤销/重做功能（保存对象的历史状态）

- **责任链模式**：
  - 理解 Android 的事件分发机制，解决触摸冲突问题
  - 使用 OkHttp 拦截器添加日志、缓存、重试等功能
  - 实现多步骤的表单验证、权限检查
  - 设计灵活的数据处理管道（过滤、转换、校验）

## 8. 练习建议

1. **原型模式练习**：
   - 复制 `prototype/PrototypeExample.java`，尝试添加更多字段（如 `List`、`Map`）
   - 实现深克隆，观察与浅克隆的区别
   - 创建一个简单的游戏角色系统，使用原型模式快速创建角色

2. **责任链模式练习**：
   - 复制 `chain/ChainExample.java`，添加新的处理节点（如"风控检查"、"黑名单过滤"）
   - 实现一个表单验证链，验证用户名、密码、邮箱等
   - 模拟 Android 的事件分发，实现一个简单的 View 层级结构

想继续练习？打开 `prototype/PrototypeExample.java`，运行代码，观察浅克隆和深克隆的区别，然后尝试自己实现一个深克隆的例子！

