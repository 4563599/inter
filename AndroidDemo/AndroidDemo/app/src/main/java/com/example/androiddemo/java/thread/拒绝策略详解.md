# 线程池拒绝策略详解

## 什么是拒绝策略？

想象一下你开了一家餐厅：
- 厨师数量有限（核心线程）
- 等候区座位有限（工作队列）
- 临时工也招满了（最大线程数）

这时候又来了新客人，怎么办？这就需要"拒绝策略"来决定如何处理。

## 什么时候会触发拒绝策略？

当同时满足以下条件时：
1. 线程池中的线程数已达到最大线程数
2. 工作队列已满
3. 又有新任务提交进来

## 四种内置拒绝策略

### 1. 中止策略（默认策略）- 直接拒绝

```java
// 直接抛出异常
new ThreadPoolExecutor.AbortPolicy()
```

**通俗理解**：餐厅直接告诉客人"满了，不接待"，然后把客人轰出去。

**适用场景**：
- 需要明确知道任务被拒绝的情况
- 对任务丢失零容忍，必须感知到问题

**示例**：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2),
    new ThreadPoolExecutor.AbortPolicy()  // 默认策略
);

try {
    executor.execute(task);
} catch (RejectedExecutionException e) {
    // 任务被拒绝，需要处理
    Log.e("ThreadPool", "任务被拒绝: " + e.getMessage());
}
```

---

### 2. 调用者运行策略 - 调用者执行

```java
// 由提交任务的线程自己执行这个任务
new ThreadPoolExecutor.CallerRunsPolicy()
```

**通俗理解**：餐厅说"厨师忙不过来，你自己去厨房炒菜吧"。

**适用场景**：
- 不想丢弃任务
- 可以接受任务执行变慢
- 希望通过"反压"机制自动降低提交速度

**示例**：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2),
    new ThreadPoolExecutor.CallerRunsPolicy()
);

// 如果线程池满了，这个任务会在主线程执行
// 主线程被占用期间，无法提交新任务，自动形成"限流"
executor.execute(task);
```

**注意**：如果在主线程提交任务，可能会阻塞主线程！

---

### 3. 丢弃策略 - 静默丢弃

```java
// 直接丢弃任务，不抛异常，不做任何处理
new ThreadPoolExecutor.DiscardPolicy()
```

**通俗理解**：餐厅假装没看见新来的客人，客人等半天没人理，自己走了。

**适用场景**：
- 任务不重要，丢了也无所谓
- 比如日志记录、统计上报等非关键任务

**示例**：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2),
    new ThreadPoolExecutor.DiscardPolicy()
);

// 任务可能被静默丢弃，调用方完全不知道
executor.execute(task);
```

**风险**：任务丢失无感知，排查问题困难！

---

### 4. 丢弃最老策略 - 丢弃最老的

```java
// 丢弃队列中等待最久的任务，然后重新提交当前任务
new ThreadPoolExecutor.DiscardOldestPolicy()
```

**通俗理解**：餐厅把等候区等最久的客人请走，让新客人坐下。

**适用场景**：
- 新任务比旧任务更重要
- 比如实时数据处理，旧数据已经没有价值

**示例**：
```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2),
    new ThreadPoolExecutor.DiscardOldestPolicy()
);

// 如果队列满了，会丢弃队列头部（最老）的任务
executor.execute(newTask);
```

---

## 自定义拒绝策略

如果内置策略不满足需求，可以实现拒绝处理器接口：

```java
public class CustomRejectedHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 方案1：记录日志
        Log.w("ThreadPool", "任务被拒绝，当前队列大小: " + executor.getQueue().size());
        
        // 方案2：持久化到数据库，稍后重试
        saveToDatabase(r);
        
        // 方案3：发送告警通知
        sendAlert("线程池已满，任务被拒绝");
        
        // 方案4：阻塞等待，直到队列有空位
        try {
            executor.getQueue().put(r);  // 阻塞式放入
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

// 使用自定义策略
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(2),
    new CustomRejectedHandler()
);
```

---

## 策略对比表

| 策略 | 行为 | 是否丢弃任务 | 是否抛异常 | 适用场景 |
|------|------|-------------|-----------|---------|
| 中止策略 | 直接拒绝 | 是 | 是 | 关键任务，需要感知拒绝 |
| 调用者运行策略 | 调用者执行 | 否 | 否 | 不能丢任务，可接受变慢 |
| 丢弃策略 | 静默丢弃 | 是 | 否 | 非关键任务 |
| 丢弃最老策略 | 丢弃最老 | 是（旧的） | 否 | 新任务更重要 |

---

## 实际开发建议

1. **生产环境慎用丢弃策略**：任务丢失无感知，出问题难排查

2. **推荐使用调用者运行策略**：既不丢任务，又能自动限流

3. **关键业务用中止策略 + 异常处理**：确保任务拒绝能被感知和处理

4. **最佳实践是自定义策略**：
   - 记录被拒绝的任务
   - 发送监控告警
   - 提供降级方案

```java
// 推荐的生产环境配置
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,
    maxPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(queueCapacity),
    new ThreadFactoryBuilder().setNameFormat("业务线程-%d").build(),
    (r, e) -> {
        // 记录日志
        Log.e("ThreadPool", "任务被拒绝，线程池状态: " + e.toString());
        // 监控上报
        Metrics.counter("threadpool.rejected").increment();
        // 根据业务决定是否重试或降级
    }
);
```

---

## 总结

拒绝策略是线程池的"最后一道防线"，选择合适的策略需要考虑：
- 任务是否可以丢失？
- 是否需要感知任务被拒绝？
- 对系统响应时间的要求？

记住：**好的系统设计应该尽量避免触发拒绝策略**，通过合理配置线程池参数，让任务能够被及时处理。
