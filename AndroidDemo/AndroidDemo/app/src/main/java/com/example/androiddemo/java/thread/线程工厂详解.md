# 线程工厂详解

## 通俗理解：工厂招聘工人

### 角色对应
```
工厂场景              →    线程池
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
招聘部门              →    线程工厂
工人                  →    线程
工人名牌              →    线程名称
工人技能等级          →    线程优先级
工人类型              →    守护线程 / 用户线程
```

## 为什么需要自定义线程工厂？

### 默认线程工厂的问题

```java
// 使用默认线程工厂
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>()
    // 没有指定线程工厂，使用默认的
);

executor.execute(() -> {
    String name = Thread.currentThread().getName();
    System.out.println("线程名: " + name);
    // 输出: 线程名: pool-1-thread-1
});
```

**问题：**
```
❌ pool-1-thread-1
❌ pool-1-thread-2
❌ pool-2-thread-1

看不出这些线程是做什么的！
```

### 自定义线程工厂的优势

```java
// 使用自定义线程工厂
ThreadFactory factory = new ThreadFactory() {
    private final AtomicInteger count = new AtomicInteger(1);
    
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, "ImageLoader-" + count.getAndIncrement());
    }
};

ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(),
    factory  // 使用自定义工厂
);

executor.execute(() -> {
    String name = Thread.currentThread().getName();
    System.out.println("线程名: " + name);
    // 输出: 线程名: ImageLoader-1
});
```

**优势：**
```
✅ ImageLoader-1
✅ ImageLoader-2
✅ NetworkWorker-1

一眼就知道是做什么的！
```

---

## 线程工厂能做什么？

### 1. 自定义线程名称

**为什么重要？**
- 调试时容易定位问题
- 日志中容易过滤
- 性能分析工具中容易识别

```java
ThreadFactory factory = new ThreadFactory() {
    private final AtomicInteger count = new AtomicInteger(1);
    private final String prefix = "MyApp-ImageLoader-";
    
    @Override
    public Thread newThread(Runnable r) {
        String name = prefix + count.getAndIncrement();
        return new Thread(r, name);
    }
};
```

**实际应用：**
```java
// 不同业务使用不同的前缀
"ImageLoader-"    // 图片加载
"NetworkWorker-"  // 网络请求
"DBWorker-"       // 数据库操作
"FileDownloader-" // 文件下载
```

---

### 2. 设置线程优先级

**优先级范围：** 1（最低）~ 10（最高），默认 5

```java
ThreadFactory factory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "Worker-" + count.getAndIncrement());
        
        // 设置优先级
        t.setPriority(Thread.NORM_PRIORITY - 1);  // 4，稍低于普通
        
        return t;
    }
};
```

**使用场景：**
```java
// 后台任务：低优先级，不影响界面
Thread.MIN_PRIORITY      // 1 - 最低优先级
Thread.NORM_PRIORITY - 1 // 4 - 稍低优先级

// 普通任务：正常优先级
Thread.NORM_PRIORITY     // 5 - 默认优先级

// 重要任务：高优先级
Thread.NORM_PRIORITY + 1 // 6 - 稍高优先级
Thread.MAX_PRIORITY      // 10 - 最高优先级（慎用）
```

**注意：** 优先级只是建议，不保证一定生效！

---

### 3. 设置守护线程

**守护线程 vs 用户线程：**

| 类型 | 特点 | 应用场景 |
|------|------|---------|
| 用户线程 | 程序会等待它执行完 | 重要任务（数据保存、网络请求） |
| 守护线程 | 程序退出时自动结束 | 后台任务（日志、监控、清理） |

```java
ThreadFactory factory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "Worker-" + count.getAndIncrement());
        
        // 设置为守护线程
        t.setDaemon(true);  // true = 守护线程
        
        return t;
    }
};
```

---

### 4. 设置异常处理器

**为什么需要？**
- 线程中的异常不会自动传播
- 未捕获的异常会导致线程终止
- 需要统一处理和记录

```java
ThreadFactory factory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "Worker-" + count.getAndIncrement());
        
        // 设置未捕获异常处理器
        t.setUncaughtExceptionHandler((thread, ex) -> {
            // 记录日志
            Log.e("ThreadPool", 
                String.format("线程 [%s] 发生异常", thread.getName()), 
                ex);
            
            // 上报到服务器
            reportToServer(thread.getName(), ex);
        });
        
        return t;
    }
};
```

---

## 完整示例

### 示例1：图片加载线程池

```java
public class ImageLoaderThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix = "ImageLoader-";
    
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
        
        // 1. 设置为用户线程（图片加载完成后才能退出）
        t.setDaemon(false);
        
        // 2. 设置稍低优先级（不影响界面线程）
        t.setPriority(Thread.NORM_PRIORITY - 1);
        
        // 3. 设置异常处理器
        t.setUncaughtExceptionHandler((thread, ex) -> {
            Log.e("ImageLoader", "图片加载失败: " + thread.getName(), ex);
        });
        
        return t;
    }
}

// 使用
ThreadPoolExecutor imageExecutor = new ThreadPoolExecutor(
    3, 6, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100),
    new ImageLoaderThreadFactory()
);
```

### 示例2：网络请求线程池

```java
public class NetworkThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "NetworkWorker-" + threadNumber.getAndIncrement());
        t.setDaemon(false);
        t.setPriority(Thread.NORM_PRIORITY);
        t.setUncaughtExceptionHandler((thread, ex) -> {
            Log.e("Network", "网络请求失败: " + thread.getName(), ex);
        });
        return t;
    }
}
```

---

## 常见陷阱

### 陷阱1：忘记设置异常处理器

```java
// ❌ 错误示例
ThreadFactory factory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, "Worker-" + count.getAndIncrement());
        // 没有设置异常处理器
    }
};

// 任务中的异常会被吞掉
executor.execute(() -> {
    throw new RuntimeException("这个异常不会被捕获！");
});
```

**解决方案：**
```java
// ✅ 正确示例
ThreadFactory factory = new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, "Worker-" + count.getAndIncrement());
        t.setUncaughtExceptionHandler((thread, ex) -> {
            Log.e("ThreadPool", "异常: " + thread.getName(), ex);
        });
        return t;
    }
};
```

### 陷阱2：守护线程处理重要任务

```java
// ❌ 错误示例
t.setDaemon(true);  // 守护线程

// 数据库保存任务
executor.execute(() -> {
    saveToDatabase(data);  // 可能没保存完就被终止了！
});
```

**解决方案：** 重要任务使用用户线程 `t.setDaemon(false)`

---

## 总结

| 功能 | 作用 | 推荐设置 |
|------|------|---------|
| 线程名称 | 便于调试和监控 | 业务相关的有意义名称 |
| 优先级 | 影响调度顺序 | 大部分用默认值 5 |
| 守护线程 | 决定程序退出行为 | 重要任务用 false |
| 异常处理器 | 捕获未处理异常 | 必须设置！ |

**记住：** 自定义线程工厂是生产环境的必备配置，不要偷懒使用默认的！
