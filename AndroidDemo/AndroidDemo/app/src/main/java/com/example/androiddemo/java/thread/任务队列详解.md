# 任务队列详解

## 通俗理解：餐厅做菜

### 角色对应
```
餐厅场景              →    线程池
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
厨师                  →    线程
点餐单                →    任务
点餐架                →    任务队列
核心厨师              →    核心线程数
最多能有几个厨师      →    最大线程数
```

## 三种队列类型对比

### 1. 数组阻塞队列 - 有界队列

**比喻：** 点餐架只能放 3 张点餐单

```
配置示例：
- 核心厨师：1 人
- 最大厨师：2 人  
- 点餐架容量：3 张

提交 5 个任务的执行流程：
┌─────────────────────────────────┐
│ 任务1 → 厨师1接单，直接做菜     │
│ 任务2 → 厨师1忙，放点餐架 [1/3] │
│ 任务3 → 厨师1忙，放点餐架 [2/3] │
│ 任务4 → 厨师1忙，放点餐架 [3/3] │
│ 任务5 → 点餐架满了！叫厨师2来   │
└─────────────────────────────────┘
```

**特点：**
- ✅ 容量固定，可控
- ✅ 队列满了会创建非核心线程
- ✅ 适合需要限流的场景

**使用场景：**
- 需要控制等待任务数量
- 防止任务堆积过多
- 需要快速失败的场景

---

### 2. 链表阻塞队列 - 无界队列

**比喻：** 点餐架无限大，可以放无数张点餐单

```
配置示例：
- 核心厨师：1 人
- 最大厨师：2 人
- 点餐架容量：无限

提交 5 个任务的执行流程：
┌─────────────────────────────────┐
│ 任务1 → 厨师1接单，直接做菜     │
│ 任务2 → 厨师1忙，放点餐架 [1/∞] │
│ 任务3 → 厨师1忙，放点餐架 [2/∞] │
│ 任务4 → 厨师1忙，放点餐架 [3/∞] │
│ 任务5 → 厨师1忙，放点餐架 [4/∞] │
│                                 │
│ ⚠️ 厨师2 永远不会被叫来！       │
└─────────────────────────────────┘
```

**特点：**
- ⚠️ 最大线程数参数失效
- ⚠️ 任务太多可能导致内存溢出
- ✅ 不会拒绝任务

**使用场景：**
- 任务量可预测且不会太大
- 不希望任务被拒绝

**风险示例：**
```java
// 危险！可能导致内存溢出
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>()  // 无界队列
);

// 如果提交 100万个任务，全部会堆积在队列中
for (int i = 0; i < 1000000; i++) {
    executor.execute(() -> {
        // 耗时任务
    });
}
// 内存可能爆掉！
```

---

### 3. 同步队列 - 直接传递

**比喻：** 没有点餐架，顾客直接把单子递给厨师

```
配置示例：
- 核心厨师：0 人
- 最大厨师：3 人
- 点餐架容量：0（没有点餐架）

提交 3 个任务的执行流程：
┌─────────────────────────────────┐
│ 任务1 → 立即创建厨师1，直接做菜 │
│ 任务2 → 立即创建厨师2，直接做菜 │
│ 任务3 → 立即创建厨师3，直接做菜 │
│                                 │
│ 💡 每个任务都会立即执行         │
└─────────────────────────────────┘
```

**特点：**
- ✅ 不存储任务，直接传递
- ✅ 每个任务都会立即创建线程执行
- ✅ 适合任务量不确定的场景

**使用场景：**
- 任务执行时间短
- 任务量波动大

---

## 如何选择队列？

### 决策树

```
开始
  │
  ├─ 任务量可预测且不大？
  │   └─ 是 → 链表阻塞队列（无界队列）
  │
  ├─ 需要限制等待任务数量？
  │   └─ 是 → 数组阻塞队列（有界队列）
  │
  └─ 任务量不确定，需要快速响应？
      └─ 是 → 同步队列（直接传递）
```

### 实际应用场景

| 场景 | 推荐队列 | 原因 |
|------|---------|------|
| 图片下载 | 数组阻塞队列(128) | 限制下载队列，避免内存占用过多 |
| 数据库操作 | 链表阻塞队列(100) | 任务量可控，不希望拒绝 |
| 网络请求 | 同步队列 | 请求量不确定，需要快速响应 |
| 日志写入 | 链表阻塞队列 | 不能丢失日志，可以排队 |
| 定时任务 | 链表阻塞队列 | 任务量固定，按时执行 |

---

## 常见陷阱

### 陷阱1：无界队列 + 大任务量 = 内存溢出

```java
// ❌ 错误示例
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 10, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>()  // 无界队列
);

// 提交大量任务
for (int i = 0; i < 1000000; i++) {
    executor.execute(() -> {
        // 任务逻辑
    });
}
// 可能导致内存溢出！
```

**解决方案：**
```java
// ✅ 正确示例
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 10, 60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(1000),  // 有界队列
    new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
);
```

### 陷阱2：有界队列 + 没有拒绝策略 = 任务丢失

```java
// ❌ 错误示例
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 2, 60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10)
    // 默认拒绝策略：抛异常
);

// 提交超过容量的任务
for (int i = 0; i < 20; i++) {
    try {
        executor.execute(() -> {
            // 任务逻辑
        });
    } catch (RejectedExecutionException e) {
        // 任务被拒绝，但没有处理！
    }
}
```

**解决方案：**
```java
// ✅ 正确示例
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 2, 60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(10),
    new ThreadPoolExecutor.CallerRunsPolicy()  // 调用者执行
);
```

---

## 最佳实践

### 1. 根据任务类型选择队列

```java
// 计算密集型任务
ThreadPoolExecutor cpuExecutor = new ThreadPoolExecutor(
    Runtime.getRuntime().availableProcessors(),
    Runtime.getRuntime().availableProcessors(),
    0L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(100)  // 有界队列
);

// 读写密集型任务
ThreadPoolExecutor ioExecutor = new ThreadPoolExecutor(
    Runtime.getRuntime().availableProcessors() * 2,
    Runtime.getRuntime().availableProcessors() * 2,
    60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(200)  // 有界队列
);

// 快速响应任务
ThreadPoolExecutor fastExecutor = new ThreadPoolExecutor(
    0,
    Integer.MAX_VALUE,
    60L, TimeUnit.SECONDS,
    new SynchronousQueue<>()  // 同步队列
);
```

### 2. 监控队列状态

```java
// 定期检查队列状态
ScheduledExecutorService monitor = Executors.newScheduledThreadPool(1);
monitor.scheduleAtFixedRate(() -> {
    int queueSize = executor.getQueue().size();
    int activeCount = executor.getActiveCount();
    
    Log.d("ThreadPool", String.format(
        "队列任务数: %d, 活跃线程数: %d",
        queueSize, activeCount
    ));
    
    // 队列堆积过多，发出警告
    if (queueSize > 100) {
        Log.w("ThreadPool", "队列堆积过多，考虑增加线程数！");
    }
}, 0, 5, TimeUnit.SECONDS);
```

### 3. 设置合理的队列容量

```java
// 根据业务场景设置容量
int queueCapacity = calculateQueueCapacity(
    averageTaskDuration,  // 平均任务耗时
    taskArrivalRate,      // 任务到达速率
    acceptableDelay       // 可接受的延迟
);

ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,
    maxPoolSize,
    keepAliveTime,
    TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(queueCapacity)
);
```

---

## 总结

| 队列类型 | 容量 | 最大线程数参数 | 适用场景 | 风险 |
|---------|------|----------------|---------|------|
| 数组阻塞队列 | 固定 | 有效 | 需要限流 | 任务可能被拒绝 |
| 链表阻塞队列 | 无限 | 无效 | 任务不能丢 | 可能内存溢出 |
| 同步队列 | 0 | 有效 | 快速响应 | 线程数可能很多 |

**记住：** 选择队列就是在 **吞吐量**、**响应速度** 和 **资源占用** 之间做权衡！
