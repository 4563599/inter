# 安卓线程池使用指南

## 四种线程池类型快速参考

| 线程池类型 | 核心线程数 | 最大线程数 | 队列类型 | 适用场景 | 典型应用 |
|-----------|-----------|-----------|---------|---------|---------|
| **固定线程池** | n | n | 链表阻塞队列 | 计算密集型任务 | 并行网络请求、批量处理 |
| **缓存线程池** | 0 | 整数最大值 | 同步队列 | 短时突发任务 | 图片解码、临时计算 |
| **单线程执行器** | 1 | 1 | 链表阻塞队列 | 顺序执行任务 | 文件写入、日志记录 |
| **定时线程池** | n | 整数最大值 | 延迟工作队列 | 定时任务 | 定时刷新、心跳检测 |

## 核心使用原则

### ✅ 推荐做法
```java
// 1. 根据任务选择合适的线程池
ExecutorService fixedPool = Executors.newFixedThreadPool(2);    // 并发控制
ExecutorService cachedPool = Executors.newCachedThreadPool();   // 突发任务
ExecutorService singlePool = Executors.newSingleThreadExecutor(); // 顺序执行
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(1); // 定时任务

// 2. 提交任务
fixedPool.execute(() -> {
    // 你的任务代码
});

// 3. 及时关闭线程池
fixedPool.shutdown(); // 优雅关闭，等待任务完成
// 或
fixedPool.shutdownNow(); // 立即关闭，中断任务
```

### ❌ 错误做法
```java
// 不要直接创建线程 - 资源浪费
new Thread(() -> {
    // 任务代码
}).start();

// 不要忘记关闭线程池 - 内存泄露
// 没有调用 shutdown()
```

## 性能调优建议

### 计算密集型任务
- 线程数 = 处理器核心数 + 1
- 使用固定线程池

### 读写密集型任务  
- 线程数 = 处理器核心数 × 2
- 可使用缓存线程池或固定线程池

### 混合型任务
- 根据实际测试调整线程数
- 监控线程池状态

## 安卓特殊注意事项

### 界面线程更新
```java
// 从工作线程切换回主线程更新UI
Handler mainHandler = new Handler(Looper.getMainLooper());
executorService.execute(() -> {
    // 后台任务
    String result = doBackgroundWork();
    
    // 切换到主线程更新UI
    mainHandler.post(() -> {
        textView.setText(result);
    });
});
```

### 生命周期管理
```java
public class MainActivity extends AppCompatActivity {
    private ExecutorService executor;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        executor = Executors.newFixedThreadPool(2);
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 重要：及时关闭线程池
        if (executor != null && !executor.isShutdown()) {
            executor.shutdownNow();
        }
    }
}
```

## 实际应用示例

### 1. 网络请求（固定线程池）
```java
ExecutorService networkPool = Executors.newFixedThreadPool(3);

// 并行发起多个网络请求
for (String url : urls) {
    networkPool.execute(() -> {
        // 执行网络请求
        String response = httpRequest(url);
        // 处理结果
    });
}
```

### 2. 图片处理（缓存线程池）
```java
ExecutorService imagePool = Executors.newCachedThreadPool();

// 批量处理图片
for (String imagePath : imagePaths) {
    imagePool.execute(() -> {
        // 解码和压缩图片
        Bitmap bitmap = decodeImage(imagePath);
        saveThumbnail(bitmap);
    });
}
```

### 3. 数据库操作（单线程执行器）
```java
ExecutorService dbPool = Executors.newSingleThreadExecutor();

// 保证数据库操作顺序执行
dbPool.execute(() -> database.insert(data1));
dbPool.execute(() -> database.update(data2));
dbPool.execute(() -> database.delete(data3));
```

### 4. 定时任务（定时线程池）
```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

// 延时执行
scheduler.schedule(() -> {
    // 5秒后执行
}, 5, TimeUnit.SECONDS);

// 周期性执行
scheduler.scheduleAtFixedRate(() -> {
    // 每30秒执行一次
}, 0, 30, TimeUnit.SECONDS);
```

## 调试和监控

### 检查线程池状态
```java
ThreadPoolExecutor pool = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);

// 获取线程池信息
int activeCount = pool.getActiveCount();      // 活跃线程数
long taskCount = pool.getTaskCount();         // 总任务数
long completedCount = pool.getCompletedTaskCount(); // 完成任务数
int queueSize = pool.getQueue().size();       // 队列大小

Log.d("ThreadPool", "活跃线程: " + activeCount + 
      ", 队列大小: " + queueSize + 
      ", 完成任务: " + completedCount);
```

## 常见陷阱

1. **忘记关闭线程池** → 内存泄露
2. **线程数设置过大** → 上下文切换开销
3. **阻塞主线程** → 应用无响应
4. **任务间有依赖** → 使用错误的线程池类型
5. **异常处理不当** → 线程意外终止

## 总结

选择线程池的决策流程：
1. **需要顺序执行？** → 单线程执行器
2. **需要定时执行？** → 定时线程池  
3. **任务量可预测？** → 固定线程池
4. **突发短任务？** → 缓存线程池

记住：**合适的线程池 + 正确的生命周期管理 = 高性能安卓应用**
